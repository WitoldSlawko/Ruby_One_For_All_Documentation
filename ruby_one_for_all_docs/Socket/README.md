# Socket < BasicSocket

(from ruby core)
---


Class `Socket` provides access to the underlying operating system socket
implementations.  It can be used to provide more operating system specific
functionality than the protocol-specific socket classes.

The constants defined under Socket::Constants are also defined under Socket. 
For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET. 
See Socket::Constants for the list of constants.

### What's a socket?

Sockets are endpoints of a bidirectional communication channel. Sockets can
communicate within a process, between processes on the same machine or between
different machines.  There are many types of socket: TCPSocket, UDPSocket or
UNIXSocket for example.

Sockets have their own vocabulary:

**domain:** The family of protocols:
*   Socket::PF_INET
*   Socket::PF_INET6
*   Socket::PF_UNIX
*   etc.


**type:** The type of communications between the two endpoints, typically
*   Socket::SOCK_STREAM
*   Socket::SOCK_DGRAM.


**protocol:** Typically *zero*. This may be used to identify a variant of a
protocol.

**hostname:** The identifier of a network interface:
*   a string (hostname, IPv4 or IPv6 address or `broadcast` which specifies a
    broadcast address)
*   a zero-length string which specifies INADDR_ANY
*   an integer (interpreted as binary address in host byte order).


### Quick start

Many of the classes, such as TCPSocket, UDPSocket or UNIXSocket, ease the use
of sockets comparatively to the equivalent C programming interface.

Let's create an internet socket using the IPv4 protocol in a C-like manner:

    require 'socket'

    s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
    s.connect Socket.pack_sockaddr_in(80, 'example.com')

You could also use the TCPSocket class:

    s = TCPSocket.new 'example.com', 80

A simple server might look like this:

    require 'socket'

    server = TCPServer.new 2000 # Server bound to port 2000

    loop do
      client = server.accept    # Wait for a client to connect
      client.puts "Hello !"
      client.puts "Time is #{Time.now}"
      client.close
    end

A simple client may look like this:

    require 'socket'

    s = TCPSocket.new 'localhost', 2000

    while line = s.gets # Read lines from socket
      puts line         # and print them
    end

    s.close             # close socket when done

### Exception Handling

Ruby's Socket implementation raises exceptions based on the error generated by
the system dependent implementation.  This is why the methods are documented
in a way that isolate Unix-based system exceptions from Windows based
exceptions. If more information on a particular exception is needed, please
refer to the Unix manual pages or the Windows WinSock reference.

### Convenience methods

Although the general way to create socket is Socket.new, there are several
methods of socket creation for most cases.

TCP client socket
:   Socket.tcp, TCPSocket.open
TCP server socket
:   Socket.tcp_server_loop, TCPServer.open
UNIX client socket
:   Socket.unix, UNIXSocket.open
UNIX server socket
:   Socket.unix_server_loop, UNIXServer.open


### Documentation by

*   Zach Dennis
*   Sam Roberts
*   *Programming Ruby* from The Pragmatic Bookshelf.


Much material in this documentation is taken with permission from *Programming
Ruby* from The Pragmatic Bookshelf.

---
# Constants:

AF_APPLETALK
:   AppleTalk protocol

AF_ATM
:   Asynchronous Transfer Mode

AF_AX25
:   AX.25 protocol

AF_CCITT
:   CCITT (now ITU-T) protocols

AF_CHAOS
:   MIT CHAOS protocols

AF_CNT
:   Computer Network Technology

AF_COIP
:   Connection-oriented IP

AF_DATAKIT
:   Datakit protocol

AF_DEC
:   DECnet protocol

AF_DLI
:   DEC Direct Data Link Interface protocol

AF_E164
:   CCITT (ITU-T) E.164 recommendation

AF_ECMA
:   European Computer Manufacturers protocols

AF_HYLINK
:   NSC Hyperchannel protocol

AF_IMPLINK
:   ARPANET IMP protocol

AF_INET
:   IPv4 protocol

AF_INET6
:   IPv6 protocol

AF_IPX
:   IPX protocol

AF_ISDN
:   Integrated Services Digital Network

AF_ISO
:   ISO Open Systems Interconnection protocols

AF_LAT
:   Local Area Transport protocol

AF_LINK
:   Link layer interface

AF_LOCAL
:   Host-internal protocols

AF_MAX
:   Maximum address family for this platform

AF_NATM
:   Native ATM access

AF_NDRV
:   Network driver raw access

AF_NETBIOS
:   NetBIOS

AF_NETGRAPH
:   Netgraph sockets

AF_NS
:   XEROX NS protocols

AF_OSI
:   ISO Open Systems Interconnection protocols

AF_PACKET
:   Direct link-layer access

AF_PPP
:   Point-to-Point Protocol

AF_PUP
:   PARC Universal Packet protocol

AF_ROUTE
:   Internal routing protocol

AF_SIP
:   Simple Internet Protocol

AF_SNA
:   IBM SNA protocol

AF_SYSTEM
:   [not documented]
AF_UNIX
:   UNIX sockets

AF_UNSPEC
:   Unspecified protocol, any supported address family

AI_ADDRCONFIG
:   Accept only if any address is assigned

AI_ALL
:   Allow all addresses

AI_CANONNAME
:   Fill in the canonical name

AI_DEFAULT
:   Default flags for getaddrinfo

AI_MASK
:   Valid flag mask for getaddrinfo (not for application use)

AI_NUMERICHOST
:   Prevent host name resolution

AI_NUMERICSERV
:   Prevent service name resolution

AI_PASSIVE
:   Get address to use with bind()

AI_V4MAPPED
:   Accept IPv4-mapped IPv6 addresses

AI_V4MAPPED_CFG
:   Accept IPv4 mapped addresses if the kernel supports it

EAI_ADDRFAMILY
:   Address family for hostname not supported

EAI_AGAIN
:   Temporary failure in name resolution

EAI_BADFLAGS
:   Invalid flags

EAI_BADHINTS
:   Invalid value for hints

EAI_FAIL
:   Non-recoverable failure in name resolution

EAI_FAMILY
:   Address family not supported

EAI_MAX
:   Maximum error code from getaddrinfo

EAI_MEMORY
:   Memory allocation failure

EAI_NODATA
:   No address associated with hostname

EAI_NONAME
:   Hostname nor servname, or not known

EAI_OVERFLOW
:   Argument buffer overflow

EAI_PROTOCOL
:   Resolved protocol is unknown

EAI_SERVICE
:   Servname not supported for socket type

EAI_SOCKTYPE
:   Socket type not supported

EAI_SYSTEM
:   System error returned in errno

IFF_802_1Q_VLAN
:   802.1Q VLAN device

IFF_ALLMULTI
:   receive all multicast packets

IFF_ALTPHYS
:   use alternate physical connection

IFF_AUTOMEDIA
:   auto media select active

IFF_BONDING
:   bonding master or slave

IFF_BRIDGE_PORT
:   device used as bridge port

IFF_BROADCAST
:   broadcast address valid

IFF_CANTCHANGE
:   flags not changeable

IFF_CANTCONFIG
:   unconfigurable using ioctl(2)

IFF_DEBUG
:   turn on debugging

IFF_DISABLE_NETPOLL
:   disable netpoll at run-time

IFF_DONT_BRIDGE
:   disallow bridging this ether dev

IFF_DORMANT
:   driver signals dormant

IFF_DRV_OACTIVE
:   tx hardware queue is full

IFF_DRV_RUNNING
:   resources allocated

IFF_DYING
:   interface is winding down

IFF_DYNAMIC
:   dialup device with changing addresses

IFF_EBRIDGE
:   ethernet bridging device

IFF_ECHO
:   echo sent packets

IFF_ISATAP
:   ISATAP interface (RFC4214)

IFF_LINK0
:   per link layer defined bit 0

IFF_LINK1
:   per link layer defined bit 1

IFF_LINK2
:   per link layer defined bit 2

IFF_LIVE_ADDR_CHANGE
:   hardware address change when it's running

IFF_LOOPBACK
:   loopback net

IFF_LOWER_UP
:   driver signals L1 up

IFF_MACVLAN_PORT
:   device used as macvlan port

IFF_MASTER
:   master of a load balancer

IFF_MASTER_8023AD
:   bonding master, 802.3ad.

IFF_MASTER_ALB
:   bonding master, balance-alb.

IFF_MASTER_ARPMON
:   bonding master, ARP mon in use

IFF_MONITOR
:   user-requested monitor mode

IFF_MULTICAST
:   supports multicast

IFF_NOARP
:   no address resolution protocol

IFF_NOTRAILERS
:   avoid use of trailers

IFF_OACTIVE
:   transmission in progress

IFF_OVS_DATAPATH
:   device used as Open vSwitch datapath port

IFF_POINTOPOINT
:   point-to-point link

IFF_PORTSEL
:   can set media type

IFF_PPROMISC
:   user-requested promisc mode

IFF_PROMISC
:   receive all packets

IFF_RENAMING
:   interface is being renamed

IFF_ROUTE
:   routing entry installed

IFF_RUNNING
:   resources allocated

IFF_SIMPLEX
:   can't hear own transmissions

IFF_SLAVE
:   slave of a load balancer

IFF_SLAVE_INACTIVE
:   bonding slave not the curr. active

IFF_SLAVE_NEEDARP
:   need ARPs for validation

IFF_SMART
:   interface manages own routes

IFF_STATICARP
:   static ARP

IFF_SUPP_NOFCS
:   sending custom FCS

IFF_TEAM_PORT
:   used as team port

IFF_TX_SKB_SHARING
:   sharing skbs on transmit

IFF_UNICAST_FLT
:   unicast filtering

IFF_UP
:   interface is up

IFF_VOLATILE
:   volatile flags

IFF_WAN_HDLC
:   WAN HDLC device

IFF_XMIT_DST_RELEASE
:   dev_hard_start_xmit() is allowed to release skb->dst

IFNAMSIZ
:   Maximum interface name size

IF_NAMESIZE
:   Maximum interface name size

INADDR_ALLHOSTS_GROUP
:   Multicast group for all systems on this subset

INADDR_ANY
:   A socket bound to INADDR_ANY receives packets from all interfaces and
    sends from the default IP address

INADDR_BROADCAST
:   The network broadcast address

INADDR_LOOPBACK
:   The loopback address

INADDR_MAX_LOCAL_GROUP
:   The last local network multicast group

INADDR_NONE
:   A bitmask for matching no valid IP address

INADDR_UNSPEC_GROUP
:   The reserved multicast group

INET6_ADDRSTRLEN
:   Maximum length of an IPv6 address string

INET_ADDRSTRLEN
:   Maximum length of an IPv4 address string

IPPORT_RESERVED
:   Default minimum address for bind or connect

IPPORT_USERRESERVED
:   Default maximum address for bind or connect

IPPROTO_AH
:   IP6 auth header

IPPROTO_BIP
:   [not documented]
IPPROTO_DSTOPTS
:   IP6 destination option

IPPROTO_EGP
:   Exterior Gateway Protocol

IPPROTO_EON
:   ISO cnlp

IPPROTO_ESP
:   IP6 Encapsulated Security Payload

IPPROTO_FRAGMENT
:   IP6 fragmentation header

IPPROTO_GGP
:   Gateway to Gateway Protocol

IPPROTO_HELLO
:   "hello" routing protocol

IPPROTO_HOPOPTS
:   IP6 hop-by-hop options

IPPROTO_ICMP
:   Control message protocol

IPPROTO_ICMPV6
:   ICMP6

IPPROTO_IDP
:   XNS IDP

IPPROTO_IGMP
:   Group Management Protocol

IPPROTO_IP
:   Dummy protocol for IP

IPPROTO_IPV6
:   IP6 header

IPPROTO_MAX
:   Maximum IPPROTO constant

IPPROTO_ND
:   Sun net disk protocol

IPPROTO_NONE
:   IP6 no next header

IPPROTO_PUP
:   PARC Universal Packet protocol

IPPROTO_RAW
:   Raw IP packet

IPPROTO_ROUTING
:   IP6 routing header

IPPROTO_TCP
:   TCP

IPPROTO_TP
:   ISO transport protocol class 4

IPPROTO_UDP
:   UDP

IPPROTO_XTP
:   Xpress Transport Protocol

IPV6_CHECKSUM
:   Checksum offset for raw sockets

IPV6_DONTFRAG
:   Don't fragment packets

IPV6_DSTOPTS
:   Destination option

IPV6_HOPLIMIT
:   Hop limit

IPV6_HOPOPTS
:   Hop-by-hop option

IPV6_JOIN_GROUP
:   Join a group membership

IPV6_LEAVE_GROUP
:   Leave a group membership

IPV6_MULTICAST_HOPS
:   IP6 multicast hops

IPV6_MULTICAST_IF
:   IP6 multicast interface

IPV6_MULTICAST_LOOP
:   IP6 multicast loopback

IPV6_NEXTHOP
:   Next hop address

IPV6_PATHMTU
:   Retrieve current path MTU

IPV6_PKTINFO
:   Receive packet information with datagram

IPV6_RECVDSTOPTS
:   Receive all IP6 options for response

IPV6_RECVHOPLIMIT
:   Receive hop limit with datagram

IPV6_RECVHOPOPTS
:   Receive hop-by-hop options

IPV6_RECVPATHMTU
:   Receive current path MTU with datagram

IPV6_RECVPKTINFO
:   Receive destination IP address and incoming interface

IPV6_RECVRTHDR
:   Receive routing header

IPV6_RECVTCLASS
:   Receive traffic class

IPV6_RTHDR
:   Allows removal of sticky routing headers

IPV6_RTHDRDSTOPTS
:   Allows removal of sticky destination options header

IPV6_RTHDR_TYPE_0
:   Routing header type 0

IPV6_TCLASS
:   Specify the traffic class

IPV6_UNICAST_HOPS
:   IP6 unicast hops

IPV6_USE_MIN_MTU
:   Use the minimum MTU size

IPV6_V6ONLY
:   Only bind IPv6 with a wildcard bind

IPX_TYPE
:   [not documented]
IP_ADD_MEMBERSHIP
:   Add a multicast group membership

IP_ADD_SOURCE_MEMBERSHIP
:   Add a multicast group membership

IP_BLOCK_SOURCE
:   Block IPv4 multicast packets with a give source address

IP_DEFAULT_MULTICAST_LOOP
:   Default multicast loopback

IP_DEFAULT_MULTICAST_TTL
:   Default multicast TTL

IP_DONTFRAG
:   Don't fragment packets

IP_DROP_MEMBERSHIP
:   Drop a multicast group membership

IP_DROP_SOURCE_MEMBERSHIP
:   Drop a multicast group membership

IP_FREEBIND
:   Allow binding to nonexistent IP addresses

IP_HDRINCL
:   Header is included with data

IP_IPSEC_POLICY
:   IPsec security policy

IP_MAX_MEMBERSHIPS
:   Maximum number multicast groups a socket can join

IP_MINTTL
:   Minimum TTL allowed for received packets

IP_MSFILTER
:   Multicast source filtering

IP_MTU
:   The Maximum Transmission Unit of the socket

IP_MTU_DISCOVER
:   Path MTU discovery

IP_MULTICAST_IF
:   IP multicast interface

IP_MULTICAST_LOOP
:   IP multicast loopback

IP_MULTICAST_TTL
:   IP multicast TTL

IP_ONESBCAST
:   Force outgoing broadcast datagrams to have the undirected broadcast
    address

IP_OPTIONS
:   IP options to be included in packets

IP_PASSSEC
:   Retrieve security context with datagram

IP_PKTINFO
:   Receive packet information with datagrams

IP_PKTOPTIONS
:   Receive packet options with datagrams

IP_PMTUDISC_DO
:   Always send DF frames

IP_PMTUDISC_DONT
:   Never send DF frames

IP_PMTUDISC_WANT
:   Use per-route hints

IP_PORTRANGE
:   Set the port range for sockets with unspecified port numbers

IP_RECVDSTADDR
:   Receive IP destination address with datagram

IP_RECVERR
:   Enable extended reliable error message passing

IP_RECVIF
:   Receive interface information with datagrams

IP_RECVOPTS
:   Receive all IP options with datagram

IP_RECVRETOPTS
:   Receive all IP options for response

IP_RECVSLLA
:   Receive link-layer address with datagrams

IP_RECVTOS
:   Receive TOS with incoming packets

IP_RECVTTL
:   Receive IP TTL with datagrams

IP_RETOPTS
:   IP options to be included in datagrams

IP_ROUTER_ALERT
:   Notify transit routers to more closely examine the contents of an IP
    packet

IP_SENDSRCADDR
:   Source address for outgoing UDP datagrams

IP_TOS
:   IP type-of-service

IP_TRANSPARENT
:   Transparent proxy

IP_TTL
:   IP time-to-live

IP_UNBLOCK_SOURCE
:   Unblock IPv4 multicast packets with a give source address

IP_XFRM_POLICY
:   [not documented]
LOCAL_CONNWAIT
:   Connect blocks until accepted

LOCAL_CREDS
:   Pass credentials to receiver

LOCAL_PEERCRED
:   Retrieve peer credentials

MCAST_BLOCK_SOURCE
:   Block multicast packets from this source

MCAST_EXCLUDE
:   Exclusive multicast source filter

MCAST_INCLUDE
:   Inclusive multicast source filter

MCAST_JOIN_GROUP
:   Join a multicast group

MCAST_JOIN_SOURCE_GROUP
:   Join a multicast source group

MCAST_LEAVE_GROUP
:   Leave a multicast group

MCAST_LEAVE_SOURCE_GROUP
:   Leave a multicast source group

MCAST_MSFILTER
:   Multicast source filtering

MCAST_UNBLOCK_SOURCE
:   Unblock multicast packets from this source

MSG_COMPAT
:   End of record

MSG_CONFIRM
:   Confirm path validity

MSG_CTRUNC
:   Control data lost before delivery

MSG_DONTROUTE
:   Send without using the routing tables

MSG_DONTWAIT
:   This message should be non-blocking

MSG_EOF
:   Data completes connection

MSG_EOR
:   Data completes record

MSG_ERRQUEUE
:   Fetch message from error queue

MSG_FASTOPEN
:   Reduce step of the handshake process

MSG_FIN
:   [not documented]
MSG_FLUSH
:   Start of a hold sequence.  Dumps to so_temp

MSG_HAVEMORE
:   Data ready to be read

MSG_HOLD
:   Hold fragment in so_temp

MSG_MORE
:   Sender will send more

MSG_NOSIGNAL
:   Do not generate SIGPIPE

MSG_OOB
:   Process out-of-band data

MSG_PEEK
:   Peek at incoming message

MSG_PROXY
:   Wait for full request

MSG_RCVMORE
:   Data remains in the current packet

MSG_RST
:   [not documented]
MSG_SEND
:   Send the packet in so_temp

MSG_SYN
:   [not documented]
MSG_TRUNC
:   Data discarded before delivery

MSG_WAITALL
:   Wait for full request or error

NI_DGRAM
:   The service specified is a datagram service (looks up UDP ports)

NI_MAXHOST
:   Maximum length of a hostname

NI_MAXSERV
:   Maximum length of a service name

NI_NAMEREQD
:   A name is required

NI_NOFQDN
:   An FQDN is not required for local hosts, return only the local part

NI_NUMERICHOST
:   Return a numeric address

NI_NUMERICSERV
:   Return the service name as a digit string

PF_APPLETALK
:   AppleTalk protocol

PF_ATM
:   Asynchronous Transfer Mode

PF_AX25
:   AX.25 protocol

PF_CCITT
:   CCITT (now ITU-T) protocols

PF_CHAOS
:   MIT CHAOS protocols

PF_CNT
:   Computer Network Technology

PF_COIP
:   Connection-oriented IP

PF_DATAKIT
:   Datakit protocol

PF_DEC
:   DECnet protocol

PF_DLI
:   DEC Direct Data Link Interface protocol

PF_ECMA
:   European Computer Manufacturers protocols

PF_HYLINK
:   NSC Hyperchannel protocol

PF_IMPLINK
:   ARPANET IMP protocol

PF_INET
:   IPv4 protocol

PF_INET6
:   IPv6 protocol

PF_IPX
:   IPX protocol

PF_ISDN
:   Integrated Services Digital Network

PF_ISO
:   ISO Open Systems Interconnection protocols

PF_KEY
:   [not documented]
PF_LAT
:   Local Area Transport protocol

PF_LINK
:   Link layer interface

PF_LOCAL
:   Host-internal protocols

PF_MAX
:   Maximum address family for this platform

PF_NATM
:   Native ATM access

PF_NDRV
:   Network driver raw access

PF_NETBIOS
:   NetBIOS

PF_NETGRAPH
:   Netgraph sockets

PF_NS
:   XEROX NS protocols

PF_OSI
:   ISO Open Systems Interconnection protocols

PF_PACKET
:   Direct link-layer access

PF_PIP
:   [not documented]
PF_PPP
:   Point-to-Point Protocol

PF_PUP
:   PARC Universal Packet protocol

PF_ROUTE
:   Internal routing protocol

PF_RTIP
:   [not documented]
PF_SIP
:   Simple Internet Protocol

PF_SNA
:   IBM SNA protocol

PF_SYSTEM
:   [not documented]
PF_UNIX
:   UNIX sockets

PF_UNSPEC
:   Unspecified protocol, any supported address family

PF_XTP
:   eXpress Transfer Protocol

SCM_BINTIME
:   Timestamp (bintime)

SCM_CREDENTIALS
:   The sender's credentials

SCM_CREDS
:   Process credentials

SCM_RIGHTS
:   Access rights

SCM_TIMESTAMP
:   Timestamp (timeval)

SCM_TIMESTAMPING
:   Timestamp (timespec list) (Linux 2.6.30)

SCM_TIMESTAMPNS
:   Timespec (timespec)

SCM_UCRED
:   User credentials

SCM_WIFI_STATUS
:   Wifi status (Linux 3.3)

SHUT_RD
:   Shut down the reading side of the socket

SHUT_RDWR
:   Shut down the both sides of the socket

SHUT_WR
:   Shut down the writing side of the socket

SOCK_DGRAM
:   A datagram socket provides connectionless, unreliable messaging

SOCK_PACKET
:   Device-level packet access

SOCK_RAW
:   A raw socket provides low-level access for direct access or implementing
    network protocols

SOCK_RDM
:   A reliable datagram socket provides reliable delivery of messages

SOCK_SEQPACKET
:   A sequential packet socket provides sequenced, reliable two-way connection
    for datagrams

SOCK_STREAM
:   A stream socket provides a sequenced, reliable two-way connection for a
    byte stream

SOL_ATALK
:   AppleTalk socket options

SOL_AX25
:   AX.25 socket options

SOL_IP
:   IP socket options

SOL_IPX
:   IPX socket options

SOL_SOCKET
:   Socket-level options

SOL_TCP
:   TCP socket options

SOL_UDP
:   UDP socket options

SOMAXCONN
:   Maximum connection requests that may be queued for a socket

SOPRI_BACKGROUND
:   Background socket priority

SOPRI_INTERACTIVE
:   Interactive socket priority

SOPRI_NORMAL
:   Normal socket priority

SO_ACCEPTCONN
:   Socket has had listen() called on it

SO_ACCEPTFILTER
:   There is an accept filter

SO_ALLZONES
:   Bypass zone boundaries

SO_ATTACH_FILTER
:   Attach an accept filter

SO_BINDTODEVICE
:   Only send packets from the given interface

SO_BINTIME
:   Receive timestamp with datagrams (bintime)

SO_BPF_EXTENSIONS
:   Query supported BPF extensions (Linux 3.14)

SO_BROADCAST
:   Permit sending of broadcast messages

SO_BUSY_POLL
:   Set the threshold in microseconds for low latency polling (Linux 3.11)

SO_DEBUG
:   Debug info recording

SO_DETACH_FILTER
:   Detach an accept filter

SO_DOMAIN
:   Domain given for socket() (Linux 2.6.32)

SO_DONTROUTE
:   Use interface addresses

SO_DONTTRUNC
:   Retain unread data

SO_ERROR
:   Get and clear the error status

SO_GET_FILTER
:   Obtain filter set by SO_ATTACH_FILTER (Linux 3.8)

SO_KEEPALIVE
:   Keep connections alive

SO_LINGER
:   Linger on close if data is present

SO_LOCK_FILTER
:   Lock the filter attached to a socket (Linux 3.9)

SO_MAC_EXEMPT
:   Mandatory Access Control exemption for unlabeled peers

SO_MARK
:   Set the mark for mark-based routing (Linux 2.6.25)

SO_MAX_PACING_RATE
:   Cap the rate computed by transport layer. [bytes per second] (Linux 3.13)

SO_NKE
:   Install socket-level Network Kernel Extension

SO_NOFCS
:   Set netns of a socket (Linux 3.4)

SO_NOSIGPIPE
:   Don't SIGPIPE on EPIPE

SO_NO_CHECK
:   Disable checksums

SO_NREAD
:   Get first packet byte count

SO_OOBINLINE
:   Leave received out-of-band data in-line

SO_PASSCRED
:   Receive SCM_CREDENTIALS messages

SO_PASSSEC
:   Toggle security context passing (Linux 2.6.18)

SO_PEEK_OFF
:   Set the peek offset (Linux 3.4)

SO_PEERCRED
:   The credentials of the foreign process connected to this socket

SO_PEERNAME
:   Name of the connecting user

SO_PEERSEC
:   Obtain the security credentials (Linux 2.6.2)

SO_PRIORITY
:   The protocol-defined priority for all packets on this socket

SO_PROTOCOL
:   Protocol given for socket() (Linux 2.6.32)

SO_RCVBUF
:   Receive buffer size

SO_RCVBUFFORCE
:   Receive buffer size without rmem_max limit (Linux 2.6.14)

SO_RCVLOWAT
:   Receive low-water mark

SO_RCVTIMEO
:   Receive timeout

SO_RECVUCRED
:   Receive user credentials with datagram

SO_REUSEADDR
:   Allow local address reuse

SO_REUSEPORT
:   Allow local address and port reuse

SO_RXQ_OVFL
:   Toggle cmsg for number of packets dropped (Linux 2.6.33)

SO_SECURITY_AUTHENTICATION
:   [not documented]
SO_SECURITY_ENCRYPTION_NETWORK
:   [not documented]
SO_SECURITY_ENCRYPTION_TRANSPORT
:   [not documented]
SO_SELECT_ERR_QUEUE
:   Make select() detect socket error queue with errorfds (Linux 3.10)

SO_SNDBUF
:   Send buffer size

SO_SNDBUFFORCE
:   Send buffer size without wmem_max limit (Linux 2.6.14)

SO_SNDLOWAT
:   Send low-water mark

SO_SNDTIMEO
:   Send timeout

SO_TIMESTAMP
:   Receive timestamp with datagrams (timeval)

SO_TIMESTAMPING
:   Time stamping of incoming and outgoing packets (Linux 2.6.30)

SO_TIMESTAMPNS
:   Receive nanosecond timestamp with datagrams (timespec)

SO_TYPE
:   Get the socket type

SO_USELOOPBACK
:   Bypass hardware when possible

SO_WANTMORE
:   Give a hint when more data is ready

SO_WANTOOBFLAG
:   OOB data is wanted in MSG_FLAG on receive

SO_WIFI_STATUS
:   Toggle cmsg for wifi status (Linux 3.3)

TCP_CONGESTION
:   TCP congestion control algorithm (Linux 2.6.13, glibc 2.6)

TCP_COOKIE_TRANSACTIONS
:   TCP Cookie Transactions (Linux 2.6.33, glibc 2.18)

TCP_CORK
:   Don't send partial frames (Linux 2.2, glibc 2.2)

TCP_DEFER_ACCEPT
:   Don't notify a listening socket until data is ready (Linux 2.4, glibc 2.2)

TCP_FASTOPEN
:   Reduce step of the handshake process (Linux 3.7, glibc 2.18)

TCP_INFO
:   Retrieve information about this socket (Linux 2.4, glibc 2.2)

TCP_KEEPCNT
:   Maximum number of keepalive probes allowed before dropping a connection
    (Linux 2.4, glibc 2.2)

TCP_KEEPIDLE
:   Idle time before keepalive probes are sent (Linux 2.4, glibc 2.2)

TCP_KEEPINTVL
:   Time between keepalive probes (Linux 2.4, glibc 2.2)

TCP_LINGER2
:   Lifetime of orphaned FIN_WAIT2 sockets (Linux 2.4, glibc 2.2)

TCP_MAXSEG
:   Set maximum segment size

TCP_MD5SIG
:   Use MD5 digests (RFC2385, Linux 2.6.20, glibc 2.7)

TCP_NODELAY
:   Don't delay sending to coalesce packets

TCP_NOOPT
:   Don't use TCP options

TCP_NOPUSH
:   Don't push the last block of write

TCP_QUEUE_SEQ
:   Sequence of a queue for repair mode (Linux 3.5, glibc 2.18)

TCP_QUICKACK
:   Enable quickack mode (Linux 2.4.4, glibc 2.3)

TCP_REPAIR
:   Repair mode (Linux 3.5, glibc 2.18)

TCP_REPAIR_OPTIONS
:   Options for repair mode (Linux 3.5, glibc 2.18)

TCP_REPAIR_QUEUE
:   Queue for repair mode (Linux 3.5, glibc 2.18)

TCP_SYNCNT
:   Number of SYN retransmits before a connection is dropped (Linux 2.4, glibc
    2.2)

TCP_THIN_DUPACK
:   Duplicated acknowledgments handling for thin-streams (Linux 2.6.34, glibc
    2.18)

TCP_THIN_LINEAR_TIMEOUTS
:   Linear timeouts for thin-streams (Linux 2.6.34, glibc 2.18)

TCP_TIMESTAMP
:   TCP timestamp (Linux 3.9, glibc 2.18)

TCP_USER_TIMEOUT
:   Max timeout before a TCP connection is aborted (Linux 2.6.37, glibc 2.18)

TCP_WINDOW_CLAMP
:   Clamp the size of the advertised window (Linux 2.4, glibc 2.2)

UDP_CORK
:   Don't send partial frames (Linux 2.5.44, glibc 2.11)



# Class methods:

    accept_loop
    getaddrinfo
    gethostbyaddr
    gethostbyname
    gethostname
    getifaddrs
    getnameinfo
    getservbyname
    getservbyport
    ip_address_list
    new
    pack_sockaddr_in
    pack_sockaddr_un
    pair
    sockaddr_in
    sockaddr_un
    socketpair
    tcp
    tcp_server_loop
    tcp_server_sockets
    udp_server_loop
    udp_server_loop_on
    udp_server_recv
    udp_server_sockets
    unix
    unix_server_loop
    unix_server_socket
    unix_socket_abstract_name?
    unpack_sockaddr_in
    unpack_sockaddr_un

# Instance methods:

    accept
    accept_nonblock
    bind
    connect
    connect_nonblock
    ipv6only!
    listen
    recvfrom
    recvfrom_nonblock
    sysaccept

# Socket::accept_loop

(from ruby core)
---
    accept_loop(*sockets) { |socket, client_addrinfo| ... }

---

yield socket and client address for each a connection accepted via given
sockets.

The arguments are a list of sockets. The individual argument should be a
socket or an array of sockets.

This method yields the block sequentially. It means that the next connection
is not accepted until the block returns. So concurrent mechanism, thread for
example, should be used to service multiple clients at a time.


# Socket::getaddrinfo

(from ruby core)
---
    Socket.getaddrinfo(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) => array

---

Obtains address information for *nodename*:*servname*.

*family* should be an address family such as: :INET, :INET6, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the family, and defaults to 0 for
the family.

*flags* should be bitwise OR of Socket::AI_* constants.

    Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)
    #=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP

    Socket.getaddrinfo("localhost", nil)
    #=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
    #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
    #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP

*reverse_lookup* directs the form of the third element, and has to be one of
below.  If *reverse_lookup* is omitted, the default value is `nil`.

    +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
    +false+, +:numeric+:  hostname is same as numeric address.
    +nil+:              obey to the current +do_not_reverse_lookup+ flag.

If Addrinfo object is preferred, use Addrinfo.getaddrinfo.


# Socket::gethostbyaddr

(from ruby core)
---
    Socket.gethostbyaddr(address_string [, address_family]) => hostent

---

Obtains the host information for *address*.

    p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))
    #=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]


# Socket::gethostbyname

(from ruby core)
---
    Socket.gethostbyname(hostname) => [official_hostname, alias_hostnames, address_family, *address_list]

---

Obtains the host information for *hostname*.

    p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2, "\x7F\x00\x00\x01"]


# Socket::gethostname

(from ruby core)
---
    Socket.gethostname => hostname

---

Returns the hostname.

    p Socket.gethostname #=> "hal"

Note that it is not guaranteed to be able to convert to IP address using
gethostbyname, getaddrinfo, etc. If you need local IP address, use
Socket.ip_address_list.


# Socket::getifaddrs

(from ruby core)
---
    Socket.getifaddrs => [ifaddr1, ...]

---

Returns an array of interface addresses. An element of the array is an
instance of Socket::Ifaddr.

This method can be used to find multicast-enabled interfaces:

    pp Socket.getifaddrs.reject {|ifaddr|
      !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)
    }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
    #=> [["eth0", 2, #<Addrinfo: 221.186.184.67>],
    #    ["eth0", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]

Example result on GNU/Linux:
    pp Socket.getifaddrs
    #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,
    #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,
    #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,
    #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]

Example result on FreeBSD:
    pp Socket.getifaddrs
    #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,
    #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]


# Socket::getnameinfo

(from ruby core)
---
    Socket.getnameinfo(sockaddr [, flags]) => [hostname, servicename]

---

Obtains name information for *sockaddr*.

*sockaddr* should be one of follows.
*   packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")
*   3-elements array such as ["AF_INET", 80, "127.0.0.1"]
*   4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]


*flags* should be bitwise OR of Socket::NI_* constants.

Note: The last form is compatible with IPSocket#addr and IPSocket#peeraddr.

    Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=> ["localhost", "www"]
    Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=> ["localhost", "www"]
    Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=> ["localhost", "www"]

If Addrinfo object is preferred, use Addrinfo#getnameinfo.


# Socket::getservbyname

(from ruby core)
---
    Socket.getservbyname(service_name)                => port_number
    Socket.getservbyname(service_name, protocol_name) => port_number

---

Obtains the port number for *service_name*.

If *protocol_name* is not given, "tcp" is assumed.

    Socket.getservbyname("smtp")          #=> 25
    Socket.getservbyname("shell")         #=> 514
    Socket.getservbyname("syslog", "udp") #=> 514


# Socket::getservbyport

(from ruby core)
---
    Socket.getservbyport(port [, protocol_name]) => service

---

Obtains the port number for *port*.

If *protocol_name* is not given, "tcp" is assumed.

    Socket.getservbyport(80)         #=> "www"
    Socket.getservbyport(514, "tcp") #=> "shell"
    Socket.getservbyport(514, "udp") #=> "syslog"


# Socket::ip_address_list

(from ruby core)
---
    Socket.ip_address_list => array

---

Returns local IP addresses as an array.

The array contains Addrinfo objects.

    pp Socket.ip_address_list
    #=> [#<Addrinfo: 127.0.0.1>,
         #<Addrinfo: 192.168.0.128>,
         #<Addrinfo: ::1>,
         ...]


# Socket::new

(from ruby core)
---
    Socket.new(domain, socktype [, protocol]) => socket

---

Creates a new socket object.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* is optional and should be a protocol defined in the domain. If
protocol is not given, 0 is used internally.

    Socket.new(:INET, :STREAM) # TCP socket
    Socket.new(:INET, :DGRAM)  # UDP socket
    Socket.new(:UNIX, :STREAM) # UNIX stream socket
    Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket


# Socket::pack_sockaddr_in

(from ruby core)
---
    Socket.pack_sockaddr_in(port, host) => sockaddr

---

Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.

    Socket.sockaddr_in(80, "127.0.0.1")
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

    Socket.sockaddr_in(80, "::1")
    #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"


# Socket::pack_sockaddr_un

(from ruby core)
---
    Socket.pack_sockaddr_un(path) => sockaddr

---

Packs *path* as an AF_UNIX sockaddr string.

    Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."


# Socket::pair

(from ruby core)
---
    Socket.pair(domain, type, protocol)       => [socket1, socket2]

---

Creates a pair of sockets connected each other.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain, defaults to 0 for the
domain.

    s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    s1.close
    p s2.recv(10) #=> "ab"
    p s2.recv(10) #=> ""
    p s2.recv(10) #=> ""

    s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "a"
    p s2.recv(10) #=> "b"


# Socket::sockaddr_in

(from ruby core)
---
    Socket.sockaddr_in(port, host)      => sockaddr

---

Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.

    Socket.sockaddr_in(80, "127.0.0.1")
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

    Socket.sockaddr_in(80, "::1")
    #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"


# Socket::sockaddr_un

(from ruby core)
---
    Socket.sockaddr_un(path)      => sockaddr

---

Packs *path* as an AF_UNIX sockaddr string.

    Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."


# Socket::socketpair

(from ruby core)
---
    Socket.socketpair(domain, type, protocol) => [socket1, socket2]

---

Creates a pair of sockets connected each other.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain, defaults to 0 for the
domain.

    s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    s1.close
    p s2.recv(10) #=> "ab"
    p s2.recv(10) #=> ""
    p s2.recv(10) #=> ""

    s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "a"
    p s2.recv(10) #=> "b"


# Socket::tcp

(from ruby core)
---
    Socket.tcp(host, port, local_host=nil, local_port=nil, [opts]) {|socket| ... }
    Socket.tcp(host, port, local_host=nil, local_port=nil, [opts])

---

creates a new socket object connected to host:port using TCP/IP.

If local_host:local_port is given, the socket is bound to it.

The optional last argument *opts* is options represented by a hash. *opts* may
have following options:

:connect_timeout
:   specify the timeout in seconds.


If a block is given, the block is called with the socket. The value of the
block is returned. The socket is closed when this method returns.

If no block is given, the socket is returned.

    Socket.tcp("www.ruby-lang.org", 80) {|sock|
      sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      sock.close_write
      puts sock.read
    }


# Socket::tcp_server_loop

(from ruby core)
---
    tcp_server_loop(host=nil, port) { |socket, client_addrinfo| ... }

---

creates a TCP/IP server on *port* and calls the block for each connection
accepted. The block is called with a socket and a client_address as an
Addrinfo object.

If *host* is specified, it is used with *port* to determine the server
addresses.

The socket is **not** closed when the block returns. So application should
close it explicitly.

This method calls the block sequentially. It means that the next connection is
not accepted until the block returns. So concurrent mechanism, thread for
example, should be used to service multiple clients at a time.

Note that Addrinfo.getaddrinfo is used to determine the server socket
addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and
IPv6 address for example, all of them are used. Socket.tcp_server_loop
succeeds if one socket can be used at least.

    # Sequential echo server.
    # It services only one client at a time.
    Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
      begin
        IO.copy_stream(sock, sock)
      ensure
        sock.close
      end
    }

    # Threaded echo server
    # It services multiple clients at a time.
    # Note that it may accept connections too much.
    Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
      Thread.new {
        begin
          IO.copy_stream(sock, sock)
        ensure
          sock.close
        end
      }
    }


# Socket::tcp_server_sockets

(from ruby core)
---
    tcp_server_sockets(host=nil, port) { |sockets| ... }

---

creates TCP/IP server sockets for *host* and *port*. *host* is optional.

If no block given, it returns an array of listening sockets.

If a block is given, the block is called with the sockets. The value of the
block is returned. The socket is closed when this method returns.

If *port* is 0, actual port number is chosen dynamically. However all sockets
in the result has same port number.

    # tcp_server_sockets returns two sockets.
    sockets = Socket.tcp_server_sockets(1296)
    p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]

    # The sockets contains IPv6 and IPv4 sockets.
    sockets.each {|s| p s.local_address }
    #=> #<Addrinfo: [::]:1296 TCP>
    #   #<Addrinfo: 0.0.0.0:1296 TCP>

    # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
    sockets = Socket.tcp_server_sockets(0)
    sockets.each {|s| p s.local_address }
    #=> #<Addrinfo: [::]:53114 TCP>
    #   #<Addrinfo: 0.0.0.0:53114 TCP>

    # The block is called with the sockets.
    Socket.tcp_server_sockets(0) {|sockets|
      p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
    }


# Socket::udp_server_loop

(from ruby core)
---
    Socket.udp_server_loop(port) {|msg, msg_src| ... }
    Socket.udp_server_loop(host, port) {|msg, msg_src| ... }

---

creates a UDP/IP server on *port* and calls the block for each message
arrived. The block is called with the message and its source information.

This method allocates sockets internally using *port*. If *host* is specified,
it is used conjunction with *port* to determine the server addresses.

The *msg* is a string.

The *msg_src* is a Socket::UDPSource object. It is used for reply.

    # UDP/IP echo server.
    Socket.udp_server_loop(9261) {|msg, msg_src|
      msg_src.reply msg
    }


# Socket::udp_server_loop_on

(from ruby core)
---
    Socket.udp_server_loop_on(sockets) {|msg, msg_src| ... }

---

Run UDP/IP server loop on the given sockets.

The return value of Socket.udp_server_sockets is appropriate for the argument.

It calls the block for each message received.


# Socket::udp_server_recv

(from ruby core)
---
    Socket.udp_server_recv(sockets) {|msg, msg_src| ... }

---

Receive UDP/IP packets from the given *sockets*. For each packet received, the
block is called.

The block receives *msg* and *msg_src*. *msg* is a string which is the payload
of the received packet. *msg_src* is a Socket::UDPSource object which is used
for reply.

Socket.udp_server_loop can be implemented using this method as follows.

    udp_server_sockets(host, port) {|sockets|
      loop {
        readable, _, _ = IO.select(sockets)
        udp_server_recv(readable) {|msg, msg_src| ... }
      }
    }


# Socket::udp_server_sockets

(from ruby core)
---
    Socket.udp_server_sockets([host, ] port)

---

Creates UDP/IP sockets for a UDP server.

If no block given, it returns an array of sockets.

If a block is given, the block is called with the sockets. The value of the
block is returned. The sockets are closed when this method returns.

If *port* is zero, some port is chosen. But the chosen port is used for the
all sockets.

    # UDP/IP echo server
    Socket.udp_server_sockets(0) {|sockets|
      p sockets.first.local_address.ip_port     #=> 32963
      Socket.udp_server_loop_on(sockets) {|msg, msg_src|
        msg_src.reply msg
      }
    }


# Socket::unix

(from ruby core)
---
    unix(path) { |socket| ... }

---

creates a new socket connected to path using UNIX socket socket.

If a block is given, the block is called with the socket. The value of the
block is returned. The socket is closed when this method returns.

If no block is given, the socket is returned.

    # talk to /tmp/sock socket.
    Socket.unix("/tmp/sock") {|sock|
      t = Thread.new { IO.copy_stream(sock, STDOUT) }
      IO.copy_stream(STDIN, sock)
      t.join
    }


# Socket::unix_server_loop

(from ruby core)
---
    unix_server_loop(path) { |socket, client_addrinfo| ... }

---

creates a UNIX socket server on *path*. It calls the block for each socket
accepted.

If *host* is specified, it is used with *port* to determine the server ports.

The socket is **not** closed when the block returns. So application should
close it.

This method deletes the socket file pointed by *path* at first if the file is
a socket file and it is owned by the user of the application. This is safe
only if the directory of *path* is not changed by a malicious user. So don't
use /tmp/malicious-users-directory/socket. Note that /tmp/socket and
/tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.

    # Sequential echo server.
    # It services only one client at a time.
    Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
      begin
        IO.copy_stream(sock, sock)
      ensure
        sock.close
      end
    }


# Socket::unix_server_socket

(from ruby core)
---
    unix_server_socket(path) { |s| ... }

---

creates a UNIX server socket on *path*

If no block given, it returns a listening socket.

If a block is given, it is called with the socket and the block value is
returned. When the block exits, the socket is closed and the socket file is
removed.

    socket = Socket.unix_server_socket("/tmp/s")
    p socket                  #=> #<Socket:fd 3>
    p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>

    Socket.unix_server_socket("/tmp/sock") {|s|
      p s                     #=> #<Socket:fd 3>
      p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
    }


# Socket::unpack_sockaddr_in

(from ruby core)
---
    Socket.unpack_sockaddr_in(sockaddr) => [port, ip_address]

---

Unpacks *sockaddr* into port and ip_address.

*sockaddr* should be a string or an addrinfo for AF_INET/AF_INET6.

    sockaddr = Socket.sockaddr_in(80, "127.0.0.1")
    p sockaddr #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]


# Socket::unpack_sockaddr_un

(from ruby core)
---
    Socket.unpack_sockaddr_un(sockaddr) => path

---

Unpacks *sockaddr* into path.

*sockaddr* should be a string or an addrinfo for AF_UNIX.

    sockaddr = Socket.sockaddr_un("/tmp/sock")
    p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"


# Socket::unix_socket_abstract_name?

(from ruby core)
---
    unix_socket_abstract_name?(path)

---


# Socket#accept

(from ruby core)
---
    socket.accept => [client_socket, client_addrinfo]

---

Accepts a next connection. Returns a new Socket object and Addrinfo object.

    serv = Socket.new(:INET, :STREAM, 0)
    serv.listen(5)
    c = Socket.new(:INET, :STREAM, 0)
    c.connect(serv.connect_address)
    p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]


# Socket#accept_nonblock

(from ruby core)
---
    socket.accept_nonblock([options]) => [client_socket, client_addrinfo]

---

Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an array containing the accepted socket
for the incoming connection, *client_socket*, and an Addrinfo,
*client_addrinfo*.

### Example
    # In one script, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.bind(sockaddr)
    socket.listen(5)
    begin # emulate blocking accept
      client_socket, client_addrinfo = socket.accept_nonblock
    rescue IO::WaitReadable, Errno::EINTR
      IO.select([socket])
      retry
    end
    puts "The client said, '#{client_socket.readline.chomp}'"
    client_socket.puts "Hello from script one!"
    socket.close

    # In another script, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.connect(sockaddr)
    socket.puts "Hello from script 2."
    puts "The server said, '#{socket.readline.chomp}'"
    socket.close

Refer to Socket#accept for the exceptions that may be thrown if the call to
*accept_nonblock* fails.

Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
used to rescue the exceptions for retrying accept_nonblock.

By specifying `exception: false`, the options hash allows you to indicate that
accept_nonblock should not raise an IO::WaitReadable exception, but return the
symbol :wait_readable instead.

### See
*   Socket#accept



# Socket#bind

(from ruby core)
---
    socket.bind(local_sockaddr) => 0

---

Binds to the given local address.

### Parameter
*   `local_sockaddr` - the `struct` sockaddr contained in a string or an
    Addrinfo object


### Example
    require 'socket'

    # use Addrinfo
    socket = Socket.new(:INET, :STREAM, 0)
    socket.bind(Addrinfo.tcp("127.0.0.1", 2222))
    p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>

    # use struct sockaddr
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )

### Unix-based Exceptions
On unix-based based systems the following system exceptions may be raised if
the call to *bind* fails:
*   Errno::EACCES - the specified *sockaddr* is protected and the current user
    does not have permission to bind to it
*   Errno::EADDRINUSE - the specified *sockaddr* is already in use
*   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
    local machine
*   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
    the family of the calling `socket`
*   Errno::EBADF - the *sockaddr* specified is not a valid file descriptor
*   Errno::EFAULT - the *sockaddr* argument cannot be accessed
*   Errno::EINVAL - the `socket` is already bound to an address, and the
    protocol does not support binding to the new *sockaddr* or the `socket`
    has been shut down.
*   Errno::EINVAL - the address length is not a valid length for the address
    family
*   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
    PATH_MAX
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTSOCK - the `socket` does not refer to a socket
*   Errno::EOPNOTSUPP - the socket type of the `socket` does not support
    binding to an address


On unix-based based systems if the address family of the calling `socket` is
Socket::AF_UNIX the follow exceptions may be raised if the call to *bind*
fails:
*   Errno::EACCES - search permission is denied for a component of the prefix
    path or write access to the `socket` is denied
*   Errno::EDESTADDRREQ - the *sockaddr* argument is a null pointer
*   Errno::EISDIR - same as Errno::EDESTADDRREQ
*   Errno::EIO - an i/o error occurred
*   Errno::ELOOP - too many symbolic links were encountered in translating the
    pathname in *sockaddr*
*   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
    characters, or an entire pathname exceeded PATH_MAX characters
*   Errno::ENOENT - a component of the pathname does not name an existing file
    or the pathname is an empty string
*   Errno::ENOTDIR - a component of the path prefix of the pathname in
    *sockaddr* is not a directory
*   Errno::EROFS - the name would reside on a read only filesystem


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *bind* fails:
*   Errno::ENETDOWN-- the network is down
*   Errno::EACCES - the attempt to connect the datagram socket to the
    broadcast address failed
*   Errno::EADDRINUSE - the socket's local address is already in use
*   Errno::EADDRNOTAVAIL - the specified address is not a valid address for
    this computer
*   Errno::EFAULT - the socket's internal address or address length parameter
    is too small or is not a valid part of the user space addressed
*   Errno::EINVAL - the `socket` is already bound to an address
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket


### See
*   bind manual pages on unix-based systems
*   bind function in Microsoft's Winsock functions reference



# Socket#connect

(from ruby core)
---
    socket.connect(remote_sockaddr) => 0

---

Requests a connection to be made on the given `remote_sockaddr`. Returns 0 if
successful, otherwise an exception is raised.

### Parameter
*   `remote_sockaddr` - the `struct` sockaddr contained in a string or
    Addrinfo object


### Example:
    # Pull down Google's web page
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
    socket.connect( sockaddr )
    socket.write( "GET / HTTP/1.0\r\n\r\n" )
    results = socket.read

### Unix-based Exceptions
On unix-based systems the following system exceptions may be raised if the
call to *connect* fails:
*   Errno::EACCES - search permission is denied for a component of the prefix
    path or write access to the `socket` is denied
*   Errno::EADDRINUSE - the *sockaddr* is already in use
*   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
    local machine
*   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
    the address family of the specified `socket`
*   Errno::EALREADY - a connection is already in progress for the specified
    socket
*   Errno::EBADF - the `socket` is not a valid file descriptor
*   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
    connections refused the connection request
*   Errno::ECONNRESET - the remote host reset the connection request
*   Errno::EFAULT - the *sockaddr* cannot be accessed
*   Errno::EHOSTUNREACH - the destination host cannot be reached (probably
    because the host is down or a remote router cannot reach it)
*   Errno::EINPROGRESS - the O_NONBLOCK is set for the `socket` and the
    connection cannot be immediately established; the connection will be
    established asynchronously
*   Errno::EINTR - the attempt to establish the connection was interrupted by
    delivery of a signal that was caught; the connection will be established
    asynchronously
*   Errno::EISCONN - the specified `socket` is already connected
*   Errno::EINVAL - the address length used for the *sockaddr* is not a valid
    length for the address family or there is an invalid family in *sockaddr*
*   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
    PATH_MAX
*   Errno::ENETDOWN - the local interface used to reach the destination is
    down
*   Errno::ENETUNREACH - no route to the network is present
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
*   Errno::EOPNOTSUPP - the calling `socket` is listening and cannot be
    connected
*   Errno::EPROTOTYPE - the *sockaddr* has a different type than the socket
    bound to the specified peer address
*   Errno::ETIMEDOUT - the attempt to connect time out before a connection was
    made.


On unix-based systems if the address family of the calling `socket` is AF_UNIX
the follow exceptions may be raised if the call to *connect* fails:
*   Errno::EIO - an i/o error occurred while reading from or writing to the
    file system
*   Errno::ELOOP - too many symbolic links were encountered in translating the
    pathname in *sockaddr*
*   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
    characters, or an entire pathname exceeded PATH_MAX characters
*   Errno::ENOENT - a component of the pathname does not name an existing file
    or the pathname is an empty string
*   Errno::ENOTDIR - a component of the path prefix of the pathname in
    *sockaddr* is not a directory


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *connect* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use
*   Errno::EINTR - the socket was cancelled
*   Errno::EINPROGRESS - a blocking socket is in progress or the service
    provider is still processing a callback function. Or a nonblocking connect
    call is in progress on the `socket`.
*   Errno::EALREADY - see Errno::EINVAL
*   Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
    ADDR_ANY TODO check ADDRANY TO INADDR_ANY
*   Errno::EAFNOSUPPORT - addresses in the specified family cannot be used
    with with this `socket`
*   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
    connections refused the connection request
*   Errno::EFAULT - the socket's internal address or address length parameter
    is too small or is not a valid part of the user space address
*   Errno::EINVAL - the `socket` is a listening socket
*   Errno::EISCONN - the `socket` is already connected
*   Errno::ENETUNREACH - the network cannot be reached from this host at this
    time
*   Errno::EHOSTUNREACH - no route to the network is present
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
*   Errno::ETIMEDOUT - the attempt to connect time out before a connection was
    made.
*   Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
    connection cannot be completed immediately
*   Errno::EACCES - the attempt to connect the datagram socket to the
    broadcast address failed


### See
*   connect manual pages on unix-based systems
*   connect function in Microsoft's Winsock functions reference



# Socket#connect_nonblock

(from ruby core)
---
    socket.connect_nonblock(remote_sockaddr, [options]) => 0

---

Requests a connection to be made on the given `remote_sockaddr` after
O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful,
otherwise an exception is raised.

### Parameter
    # +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object

### Example:
    # Pull down Google's web page
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(80, 'www.google.com')
    begin # emulate blocking connect
      socket.connect_nonblock(sockaddr)
    rescue IO::WaitWritable
      IO.select(nil, [socket]) # wait 3-way handshake completion
      begin
        socket.connect_nonblock(sockaddr) # check connection failure
      rescue Errno::EISCONN
      end
    end
    socket.write("GET / HTTP/1.0\r\n\r\n")
    results = socket.read

Refer to Socket#connect for the exceptions that may be thrown if the call to
*connect_nonblock* fails.

Socket#connect_nonblock may raise any error corresponding to connect(2)
failure, including Errno::EINPROGRESS.

If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable. So
IO::WaitWritable can be used to rescue the exceptions for retrying
connect_nonblock.

By specifying `exception: false`, the options hash allows you to indicate that
connect_nonblock should not raise an IO::WaitWritable exception, but return
the symbol :wait_writable instead.

### See
    # Socket#connect


# Socket#ipv6only!

(from ruby core)
---
    ipv6only!()

---

enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.


# Socket#listen

(from ruby core)
---
    socket.listen( int ) => 0

---

Listens for connections, using the specified `int` as the backlog. A call to
*listen* only applies if the `socket` is of type SOCK_STREAM or
SOCK_SEQPACKET.

### Parameter
*   `backlog` - the maximum length of the queue for pending connections.


### Example 1
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )

### Example 2 (listening on an arbitrary port, unix-based systems only):
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    socket.listen( 1 )

### Unix-based Exceptions
On unix based systems the above will work because a new `sockaddr` struct is
created on the address ADDR_ANY, for an arbitrary port number as handed off by
the kernel. It will not work on Windows, because Windows requires that the
`socket` is bound by calling *bind* before it can *listen*.

If the *backlog* amount exceeds the implementation-dependent maximum queue
length, the implementation's maximum queue length will be used.

On unix-based based systems the following system exceptions may be raised if
the call to *listen* fails:
*   Errno::EBADF - the *socket* argument is not a valid file descriptor
*   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
    the protocol does not support listening on an unbound socket
*   Errno::EINVAL - the *socket* is already connected
*   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
*   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
*   Errno::EACCES - the calling process does not have appropriate privileges
*   Errno::EINVAL - the *socket* has been shut down
*   Errno::ENOBUFS - insufficient resources are available in the system to
    complete the call


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *listen* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use. This
    usually occurs during the execution of *bind* but could be delayed if the
    call to *bind* was to a partially wildcard address (involving ADDR_ANY)
    and if a specific address needs to be committed at the time of the call to
    *listen*
*   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
    service provider is still processing a callback function
*   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
*   Errno::EISCONN - the `socket` is already connected
*   Errno::EMFILE - no more socket descriptors are available
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOC - `socket` is not a socket
*   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
    the *listen* method


### See
*   listen manual pages on unix-based systems
*   listen function in Microsoft's Winsock functions reference



# Socket#recvfrom

(from ruby core)
---
    socket.recvfrom(maxlen) => [mesg, sender_addrinfo]
    socket.recvfrom(maxlen, flags) => [mesg, sender_addrinfo]

---

Receives up to *maxlen* bytes from `socket`. *flags* is zero or more of the
`MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_addrinfo*, contains protocol-specific
address information of the sender.

### Parameters
*   `maxlen` - the maximum number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options


### Example
    # In one file, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )
    client, client_addrinfo = socket.accept
    data = client.recvfrom( 20 )[0].chomp
    puts "I only received 20 bytes '#{data}'"
    sleep 1
    socket.close

    # In another file, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.connect( sockaddr )
    socket.puts "Watch this get cut short!"
    socket.close

### Unix-based Exceptions
On unix-based based systems the following system exceptions may be raised if
the call to *recvfrom* fails:
*   Errno::EAGAIN - the `socket` file descriptor is marked as O_NONBLOCK and
    no data is waiting to be received; or MSG_OOB is set and no out-of-band
    data is available and either the `socket` file descriptor is marked as
    O_NONBLOCK or the `socket` does not support blocking to wait for
    out-of-band-data
*   Errno::EWOULDBLOCK - see Errno::EAGAIN
*   Errno::EBADF - the `socket` is not a valid file descriptor
*   Errno::ECONNRESET - a connection was forcibly closed by a peer
*   Errno::EFAULT - the socket's internal buffer, address or address length
    cannot be accessed or written
*   Errno::EINTR - a signal interrupted *recvfrom* before any data was
    available
*   Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
    available
*   Errno::EIO - an i/o error occurred while reading from or writing to the
    filesystem
*   Errno::ENOBUFS - insufficient resources were available in the system to
    perform the operation
*   Errno::ENOMEM - insufficient memory was available to fulfill the request
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
    is not connected
*   Errno::ENOTSOCK - the `socket` does not refer to a socket
*   Errno::EOPNOTSUPP - the specified flags are not supported for this socket
    type
*   Errno::ETIMEDOUT - the connection timed out during connection
    establishment or due to a transmission timeout on an active connection


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *recvfrom* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EFAULT - the internal buffer and from parameters on `socket` are
    not part of the user address space, or the internal fromlen parameter is
    too small to accommodate the peer address
*   Errno::EINTR - the (blocking) call was cancelled by an internal call to
    the WinSock function WSACancelBlockingCall
*   Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
    the service provider is still processing a callback function
*   Errno::EINVAL - `socket` has not been bound with a call to *bind*, or an
    unknown flag was specified, or MSG_OOB was specified for a socket with
    SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
    len parameter on `socket` was zero or negative
*   Errno::EISCONN - `socket` is already connected. The call to *recvfrom* is
    not permitted with a connected socket on a socket that is connection
    oriented or connectionless.
*   Errno::ENETRESET - the connection has been broken due to the keep-alive
    activity detecting a failure while the operation was in progress.
*   Errno::EOPNOTSUPP - MSG_OOB was specified, but `socket` is not
    stream-style such as type SOCK_STREAM. OOB data is not supported in the
    communication domain associated with `socket`, or `socket` is
    unidirectional and supports only send operations
*   Errno::ESHUTDOWN - `socket` has been shutdown. It is not possible to call
    *recvfrom* on a socket after *shutdown* has been invoked.
*   Errno::EWOULDBLOCK - `socket` is marked as nonblocking and a  call to
    *recvfrom* would block.
*   Errno::EMSGSIZE - the message was too large to fit into the specified
    buffer and was truncated.
*   Errno::ETIMEDOUT - the connection has been dropped, because of a network
    failure or because the system on the other end went down without notice
*   Errno::ECONNRESET - the virtual circuit was reset by the remote side
    executing a hard or abortive close. The application should close the
    socket; it is no longer usable. On a UDP-datagram socket this error
    indicates a previous send operation resulted in an ICMP Port Unreachable
    message.



# Socket#recvfrom_nonblock

(from ruby core)
---
    socket.recvfrom_nonblock(maxlen[, flags[, outbuf[, opts]]]) => [mesg, sender_addrinfo]

---

Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
is set for the underlying file descriptor. *flags* is zero or more of the
`MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_addrinfo*, contains protocol-specific
address information of the sender.

When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string
as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP,
etc.

### Parameters
*   `maxlen` - the maximum number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options
*   `outbuf` - destination String buffer
*   `opts` - keyword hash, supporting `exception: false`


### Example
    # In one file, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.bind(sockaddr)
    socket.listen(5)
    client, client_addrinfo = socket.accept
    begin # emulate blocking recvfrom
      pair = client.recvfrom_nonblock(20)
    rescue IO::WaitReadable
      IO.select([client])
      retry
    end
    data = pair[0].chomp
    puts "I only received 20 bytes '#{data}'"
    sleep 1
    socket.close

    # In another file, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.connect(sockaddr)
    socket.puts "Watch this get cut short!"
    socket.close

Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
*recvfrom_nonblock* fails.

Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
retrying recvfrom_nonblock.

By specifying `exception: false`, the options hash allows you to indicate that
accept_nonblock should not raise an IO::WaitReadable exception, but return the
symbol :wait_readable instead.

### See
*   Socket#recvfrom



# Socket#sysaccept

(from ruby core)
---
    socket.sysaccept => [client_socket_fd, client_addrinfo]

---

Accepts an incoming connection returning an array containing the (integer)
file descriptor for the incoming connection, *client_socket_fd*, and an
Addrinfo, *client_addrinfo*.

### Example
    # In one script, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )
    client_fd, client_addrinfo = socket.sysaccept
    client_socket = Socket.for_fd( client_fd )
    puts "The client said, '#{client_socket.readline.chomp}'"
    client_socket.puts "Hello from script one!"
    socket.close

    # In another script, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.connect( sockaddr )
    socket.puts "Hello from script 2."
    puts "The server said, '#{socket.readline.chomp}'"
    socket.close

Refer to Socket#accept for the exceptions that may be thrown if the call to
*sysaccept* fails.

### See
*   Socket#accept



