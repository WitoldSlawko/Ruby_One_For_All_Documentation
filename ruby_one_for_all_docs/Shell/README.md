# Shell < Object

---
# Includes:
Error (from ruby core)

---
# Extended by:
(from ruby core)
    Exception2MessageMapper
    Forwardable

(from ruby core)
---
Shell implements an idiomatic Ruby interface for common UNIX shell commands.

It provides users the ability to execute commands with filters and pipes, like
`sh`/`csh` by using native facilities of Ruby.

## Examples

### Temp file creation

In this example we will create three `tmpFile`'s in three different folders
under the `/tmp` directory.

    sh = Shell.cd("/tmp") # Change to the /tmp directory
    sh.mkdir "shell-test-1" unless sh.exists?("shell-test-1")
    # make the 'shell-test-1' directory if it doesn't already exist
    sh.cd("shell-test-1") # Change to the /tmp/shell-test-1 directory
    for dir in ["dir1", "dir3", "dir5"]
      if !sh.exists?(dir)
        sh.mkdir dir # make dir if it doesn't already exist
        sh.cd(dir) do
          # change to the `dir` directory
          f = sh.open("tmpFile", "w") # open a new file in write mode
          f.print "TEST\n"            # write to the file
          f.close                     # close the file handler
        end
        print sh.pwd                  # output the process working directory
      end
    end

### Temp file creation with self

This example is identical to the first, except we're using
CommandProcessor#transact.

CommandProcessor#transact executes the given block against self, in this case
`sh`; our Shell object. Within the block we can substitute `sh.cd` to `cd`,
because the scope within the block uses `sh` already.

    sh = Shell.cd("/tmp")
    sh.transact do
      mkdir "shell-test-1" unless exists?("shell-test-1")
      cd("shell-test-1")
      for dir in ["dir1", "dir3", "dir5"]
        if !exists?(dir)
          mkdir dir
          cd(dir) do
            f = open("tmpFile", "w")
            f.print "TEST\n"
            f.close
          end
          print pwd
        end
      end
    end

### Pipe /etc/printcap into a file

In this example we will read the operating system file `/etc/printcap`,
generated by `cupsd`, and then output it to a new file relative to the `pwd`
of `sh`.

    sh = Shell.new
    sh.cat("/etc/printcap") | sh.tee("tee1") > "tee2"
    (sh.cat < "/etc/printcap") | sh.tee("tee11") > "tee12"
    sh.cat("/etc/printcap") | sh.tee("tee1") >> "tee2"
    (sh.cat < "/etc/printcap") | sh.tee("tee11") >> "tee12"





---
# Class methods:

    alias_command
    cascade
    cd
    debug
    debug=
    debug?
    def_system_command
    default_record_separator
    default_record_separator=
    default_system_path
    default_system_path=
    install_system_commands
    new
    notify
    unalias_command
    undef_system_command
    verbose
    verbose?

# Instance methods:

    cd
    chdir
    command_processor
    cwd
    debug
    debug=
    debug?
    dir
    dir_stack
    dirs
    expand_path
    getwd
    inspect
    jobs
    kill
    popd
    popdir
    process_controller
    pushd
    pushdir
    pwd
    record_separator
    system_path
    system_path=
    umask
    verbose
    verbose?

# Attributes:

    attr_accessor cascade
    attr_accessor record_separator
    attr_accessor umask
    attr_accessor verbose
    attr_accessor verbose?
    attr_reader command_processor
    attr_reader cwd
    attr_reader debug
    attr_reader debug?
    attr_reader dir
    attr_reader dir_stack
    attr_reader dirs
    attr_reader getwd
    attr_reader process_controller
    attr_reader pwd
    attr_reader system_path

# Shell::alias_command

(from ruby core)
---
    alias_command(alias, command, *opts, &block)

---

Convenience method for Shell::CommandProcessor.alias_command. Defines an
instance method which will execute a command under an alternative name.

    Shell.def_system_command('date')
    Shell.alias_command('date_in_utc', 'date', '-u')
    Shell.new.date_in_utc # => Sat Jan 25 16:59:57 UTC 2014


# Shell::cd

(from ruby core)
---
    Shell.cd(path)

---

Creates a new Shell instance with the current working directory set to `path`.


# Shell::debug=

(from ruby core)
---
    debug=(val)

---


# Shell::def_system_command

(from ruby core)
---
    def_system_command(command, path = command)

---

Convenience method for Shell::CommandProcessor.def_system_command. Defines an
instance method which will execute the given shell command. If the executable
is not in Shell.default_system_path, you must supply the path to it.

    Shell.def_system_command('hostname')
    Shell.new.hostname # => localhost

    # How to use an executable that's not in the default path

    Shell.def_system_command('run_my_program', "~/hello")
    Shell.new.run_my_program # prints "Hello from a C program!"


# Shell::default_record_separator

(from ruby core)
---
    default_record_separator()

---


# Shell::default_record_separator=

(from ruby core)
---
    default_record_separator=(rs)

---


# Shell::default_system_path

(from ruby core)
---
    default_system_path()

---

Returns the directories in the current shell's PATH environment variable as an
array of directory names. This sets the system_path for all instances of
Shell.

Example: If in your current shell, you did:

    $ echo $PATH
    /usr/bin:/bin:/usr/local/bin

Running this method in the above shell would then return:

    ["/usr/bin", "/bin", "/usr/local/bin"]


# Shell::default_system_path=

(from ruby core)
---
    default_system_path=(path)

---

Sets the system_path that new instances of Shell should have as their initial
system_path.

`path` should be an array of directory name strings.


# Shell::install_system_commands

(from ruby core)
---
    install_system_commands(pre = "sys_")

---

Convenience method for Shell::CommandProcessor.install_system_commands.
Defines instance methods representing all the executable files found in
Shell.default_system_path, with the given prefix prepended to their names.

    Shell.install_system_commands
    Shell.new.sys_echo("hello") # => hello


# Shell::new

(from ruby core)
---
    Shell.new(pwd, umask) -> obj

---

Creates a Shell object which current directory is set to the process current
directory, unless otherwise specified by the `pwd` argument.


# Shell::notify

(from ruby core)
---
    notify(*opts) { |mes| ... }

---


# Shell::unalias_command

(from ruby core)
---
    unalias_command(ali)

---

Convenience method for Shell::CommandProcessor.unalias_command


# Shell::undef_system_command

(from ruby core)
---
    undef_system_command(command)

---

Convenience method for Shell::CommandProcessor.undef_system_command


# Shell#cd

(from ruby core)
---
    cd(path = nil, verbose = @verbose)

---


# Shell#chdir

(from ruby core)
---
    Shell.chdir(path)

---

Creates a Shell object which current directory is set to `path`.

If a block is given, it restores the current directory when the block ends.

If called as iterator, it restores the current directory when the block ends.


# Shell#debug=

(from ruby core)
---
    debug=(val)

---


# Shell#expand_path

(from ruby core)
---
    expand_path(path)

---


# Shell#inspect

(from ruby core)
---
    inspect()

---

#### (Uses superclass method RDoc::AnyMethod: Object#inspect)
---


# Shell#jobs

(from ruby core)
---
    jobs()

---

Returns a list of scheduled jobs.


# Shell#kill

(from ruby core)
---
    kill(signal, job)

---

Sends the given `signal` to the given `job`


# Shell#popd

(from ruby core)
---
    popd()

---


# Shell#popdir

(from ruby core)
---
    popdir()

---

Pops a directory from the directory stack, and sets the current directory to
it.


# Shell#pushd

(from ruby core)
---
    pushd(path = nil, verbose = @verbose)

---


# Shell#pushdir

(from ruby core)
---
    pushdir(path)
    pushdir(path) { &block }

---

Pushes the current directory to the directory stack, changing the current
directory to `path`.

If `path` is omitted, it exchanges its current directory and the top of its
directory stack.

If a block is given, it restores the current directory when the block ends.


# Shell#system_path=

(from ruby core)
---
    system_path=(path)

---

Sets the system path (the Shell instance's PATH environment variable).

`path` should be an array of directory name strings.


